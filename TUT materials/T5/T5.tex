% Created 2022-11-01 Tue 12:13
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\lstdefinestyle{mystyle}{
backgroundcolor=\color{backcolour},
commentstyle=\color{codegreen},
keywordstyle=\color{magenta},
numberstyle=\tiny\color{codegray},
stringstyle=\color{codepurple},
basicstyle=\ttfamily\footnotesize,
breakatwhitespace=false,
breaklines=true,
captionpos=b,
keepspaces=true,
numbers=left,
numbersep=5pt,
showspaces=false,
showstringspaces=false,
showtabs=false,
tabsize=2
}
\lstset{style=mystyle, language=Python}
\author{Habib Ghaffari}
\date{\textit{<2022-10-31 Mon>}}
\title{Tutorial \#5 - Let's have a review together}
\hypersetup{
 pdfauthor={Habib Ghaffari},
 pdftitle={Tutorial \#5 - Let's have a review together},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 28.1 (Org mode 9.5.2)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents



\section{Introduction}
\label{s1}
Today I am going to review some of the topics related to the course. While we
are doing this, we are also going to solve some examples that may help you
figure out the kind of questions you may have in your mid-term. Let's start.

\section{Language definition}
\label{sec:orgf598a4c}

\subsection{Alphabet, Sentence and Language}
\label{sec:org4609a65}

\begin{itemize}
\item An \textbf{alphabet} is finite non-empty set. The element of an alphabet called the
letters or symbols of the alphabet.
\item A \textbf{sentence} is a string of characters over some alphabet.
\item A \textbf{language} is a set of sentences.
\end{itemize}


Lets have a look at an example:

\begin{itemize}
\item Here is the alphabet for our language:
\end{itemize}

\begin{verbatim}
A={a b... z A B .. Z 0 ... 9 _}
\end{verbatim}

This is a possible alphabet for \texttt{Python} programming language.

Lets give you a definition based on the alphabet:

digits = (0 | 1 | 2 | 3 | 4 | 5 )*
words = (a | b | c | d | e | f | g ) +
pattern =  word ( \_ | (digits)*)

Let's write some valid patterns based on this definition:

\begin{itemize}
\item pattern1 = abz\_
\item pattern2 = abcd0128
\item pattern3 = abc345
\item pattern4 = g\_
\end{itemize}

Give me one more valid and invalid pattern. Justify your answer:

\begin{itemize}
\item valid pattern :
\item in-valid pattern :
\end{itemize}


\begin{verbatim}
A={a b ... z A B ... z 0 ... 9 _ '}
\end{verbatim}

This is another possible alphabet for \texttt{Haskell} programming language.

Let's define a different pattern definition:

digits (1|2| \ldots{} |9)+
words = (A|B| \ldots{} |Z | ')*
pattern digits ( ' | (\_ words)*)

Give me some valid and invalid patterns:

\begin{itemize}
\item Valid\textsubscript{pattern1} : 123'
\item Valid\textsubscript{pattern2} :
\item Valid\textsubscript{pattern3} :
\item Valid\textsubscript{pattern4} :

\item Invalid\textsubscript{pattern1} : 10233\textsubscript{WoRD}'
\item Invalid\textsubscript{pattern2} :
\item Invalid\textsubscript{pattern3} :
\item Invalid\textsubscript{pattern4} :
\end{itemize}

Lets define a regular expression:

((a|b|c|d|\ldots{}|z|A|B|\ldots{}|Z|0|1|\ldots{}|9|)+(a|b|c|d|\ldots{}|z|A|B|\ldots{}|Z|0|1|\ldots{}|9|\_)*(a|b|c|d|\ldots{}|z|A|B|\ldots{}|Z|0|1|\ldots{}|9|)+)@((a|b|\ldots{}|z)+).((a|b|\ldots{}|z)+)

Let's write down some strings matching the above regular expressions:

\begin{itemize}
\item 

\item 

\item 
\end{itemize}

Let's write some strings that do not match the above regular expression:

\begin{itemize}
\item 

\item 

\item 
\end{itemize}

\subsection{Lexem and Token:}
\label{sec:orgc175f2a}

\begin{itemize}
\item A lexeme is the lowest level syntactic unit of a language (*, sum, begin)

\item A token is a category of lexemes
\end{itemize}

In a practical programming language, there are a very large number of lexemes,
perhaps even an infinite number. In a practical programming language, there are
only a small number of tokens.

Let's have a look at one simple example

\begin{verbatim}
while (y  >=  t) y  =  y - 3 ;
\end{verbatim}

Let's identify the lexems and tokens here:

\begin{center}
\begin{tabular}{ll}
\hline
Lexem & Token\\
\hline
while & WHILE\\
\hline
( & LPar\\
\hline
y & Identifier\\
\hline
<= & Comparison\\
\hline
t & Identifier\\
\hline
) & Rpar\\
\hline
y & Identifier\\
\hline
= & Assignment\\
\hline
y & Identifier\\
\hline
- & Arithmetic\\
\hline
3 & Integer\\
\hline
; & Semicolon\\
\hline
\end{tabular}
\end{center}

As you can see we have an almost unlimited number of lexems while we are going to end
up with a limited number of lexical categories (Tokens).


Let's look at another example:

\begin{verbatim}
A = {t r u e f a l s e u c p d o i h n Z 0 ( ) ;}
\end{verbatim}

\begin{center}
\begin{tabular}{ll}
\hline
Lexem & Token\\
\hline
isZero & IsZero\\
\hline
( & LPar\\
\hline
predecessor & operator\\
\hline
sucessor & operator\\
\hline
isZero & operator\\
\hline
) & Rpar\\
\hline
true & constant\\
\hline
false & constant\\
\hline
0 & Zero\\
\hline
if then else & conditional\\
\hline
; & EOF\\
\hline
\end{tabular}
\end{center}

\section{Context-Free Grammars, BNF, E-BNF}
\label{sec:org155572f}


In formal language theory, a context-free grammar (CFG) is a formal grammar
whose production rules are of the form

\begin{verbatim}
A -> alpha
\end{verbatim}

with \textbf{A} as a \textbf{nont-terminal} symbol and \textbf{alpha} as \textbf{terminal} / \textbf{non-terminal}
/ \textbf{empty} symbols.

Backus-Naur form (BNF): In BNF, abstractions are used to represent classes of
syntactic structures--they act like syntactic variables (also called nonterminal
symbols, or just terminals)


Let's have a look at one example:

Other name for non-terminal symbol is abstractions.

Abstractions can have more than one RHS

\begin{verbatim}
<program> → <stmts>
<stmts> → <stmt> | <stmt> ; <stmts>
<stmt> → <var> = <expr>
<var> → a|b|c|d
<expr> → <term> + <term> | <term> - <term> <term> → <var> | const
\end{verbatim}

Can you identify non-terminal and terminal symbols here?

Let's have a look at another example:

\begin{verbatim}
⟨H_ID⟩  → ⟨head⟩ ⟨tail⟩
⟨head⟩  → ⟨upper⟩ | ⟨lower⟩
⟨tail⟩  → ⟨upper⟩ | ⟨lower⟩ | ⟨special⟩ | ⟨digit⟩ | ’
⟨lower⟩ → a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z|
⟨upper⟩ → A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W |X|Y|Z
⟨digit⟩ → 0|1|2|3|4|5|6|7|8|9
\end{verbatim}

can you identify the terminal and non terminal symbols here:

Let's define some valid identifiers:

\begin{itemize}
\item Valid\textsubscript{identifier1}: habib1'
\item Valid\textsubscript{identifier2}: Habib2'
\item Valid\textsubscript{identifier3}: HhAaBbIiBb
\end{itemize}

Let's define some invalid identifiers:

\begin{itemize}
\item Invalid\textsubscript{identifier}: 1Habib
\item Invalid\textsubscript{identifier}:
\item Invalid\textsubscript{identifier}:
\end{itemize}

Let's have a look at another interesting activity:


\url{https://www.ics.uci.edu/\~pattis/ICS-31/lectures/tokens.pdf}


Let's do an fun activity together:


\begin{center}
\includegraphics[width=0.8\textwidth]{./figures/jude.jpg}
\label{fig1}
\end{center}

Lets write a EBNF grammar for this song:

\begin{verbatim}
⟨Song⟩ ::= ⟨Jude⟩ { ⟨Jude⟩ }
⟨Jude⟩ ::= hey Jude don’t ⟨line 1⟩ remember to ⟨line 2⟩ then you (can start | begin) to make it better
⟨nas⟩
⟨line1⟩ ::= make it bad take a sad song and make it better
            | be afraid you were made to go out and get her
            | let me down you have found her, now go and get her
⟨line2⟩ ::= let her into your heart
            | let her under your skin
⟨nas⟩ ::= na {na}
\end{verbatim}

Now lets have a look at a bit harder case.

\begin{itemize}
\item For loop in C:
\end{itemize}

\begin{verbatim}
⟨C For Loop⟩ ::= for ( ⟨initializer⟩ ; ⟨conditional⟩ ; ⟨update⟩ ) ’{’ ⟨Statements⟩ ’}’
\end{verbatim}

\begin{itemize}
\item Exercise: Define  EBNF grammar for tuples in \texttt{Python}:
\end{itemize}


\subsection{Ambigious and non-Ambigious grammars:}
\label{sec:orgb65d176}


A grammar is ambiguous if and only if it generates a sentential form that has
two or more distinct parse trees:

\begin{verbatim}
E -> E+E|id
\end{verbatim}

\begin{center}
\includegraphics[width=0.8\textwidth]{./figures/grammertree2.jpeg}
\label{fig5}
\end{center}


Now let's have a look at a bit more different example. See how we could figure
out if it is ambiguous or not:

\begin{verbatim}
S ->  if E then S else S
S ->  begin S L
S ->  print E
L -> end
L -> S L
E ->  num = num
\end{verbatim}

What do you think about this grammar?

\begin{itemize}
\item S expression starts either with an IF, BEGIN, or PRINT token,

\item L expression start with an END or a SEMICOLON token,

\item E expression has only one production.
\end{itemize}

What about the following grammar?

\begin{verbatim}
E -> E-E | id
\end{verbatim}

Define some of the strings in the language:

\begin{verbatim}
{ id, id-id, id-id-id, ….}
\end{verbatim}


Consider the following string in the language by replacing terminal \texttt{id} with
\texttt{3}.

\begin{verbatim}
3 - 3 - 3 
\end{verbatim}


Here is what we may expect:


\begin{center}
\includegraphics[width=0.8\textwidth]{./figures/grammertree1.jpeg}
\label{fig4}
\end{center}


How we could make this grammar unambiguous?


\begin{enumerate}
\item Precedence:
\end{enumerate}
If different operators are used, we will consider the precedence of the
operators. The three important characteristics are :

\begin{enumerate}
\item The level at which the production is present denotes the priority of the
operator used.
\item The production at higher levels will have operators with less priority. In
the parse tree, the nodes which are at top levels or close to the root
node will contain the lower priority operators.
\item The production at lower levels will have operators with higher priority.
In the parse tree, the nodes which are at lower levels or close to the
leaf nodes will contain the higher-priority operators.
\end{enumerate}
\begin{enumerate}
\item Associativity:
\end{enumerate}
If the same precedence operators are in production, then we will have to
consider the associativity.

\begin{enumerate}
\item If the associativity is left to right, then we have to prompt a left
recursion in the production. The parse tree will also be left recursive
and grow on the left side.
\item +, -, *, / are left-associative operators.
\item If the associativity is right to left, then we have to prompt the right
recursion in the productions. The parse tree will also be right recursive
and grow on the right side.
\item \^{} is a right associative operator.
\end{enumerate}


\begin{itemize}
\item Make the grammar left recursive:

\begin{itemize}
\item Replace the most non-terminal E in the RHS with another random variable.
\end{itemize}
\end{itemize}

\begin{verbatim}
E -> E – P | P
P -> id
\end{verbatim}

\begin{center}
\includegraphics[width=0.8\textwidth]{./figures/f1.png}
\label{fig2}
\end{center}

\begin{center}
\includegraphics[width=0.8\textwidth]{./figures/f2.png}
\label{fig3}
\end{center}


\begin{itemize}
\item Consider the following grammar:
\end{itemize}

\begin{verbatim}
E -> E + E | E * E | id
\end{verbatim}

Is this ambiguous? How we could prove that? If it is, how we could show it is
not

\begin{itemize}
\item example: 3+2*5
\end{itemize}


\begin{verbatim}
E -> E + P           // + is at higher level and left associative
E -> P 
P -> P * Q          // * is at lower level and left associative
P -> Q  
Q -> id
\end{verbatim}


What about this example?


\begin{verbatim}
E -> T + E
E -> T
T -> int
T -> int * T
T -> ( E )
\end{verbatim}

\begin{itemize}
\item E starts with T or T + E
\item T starts with int or int * T or (E)

Definitely, this is not predictive grammar.

How could we make it predicitve?

Let's add up some random non-terminals to the grammar to make it predictive.
\end{itemize}

\begin{verbatim}
E -> T X
X -> + E 
X -> epsilon
T -> (E)
T -> int Y
Y -> * T
Y -> epsilon
\end{verbatim}

\begin{itemize}
\item Check all the repetitive terminal symbols
\item Make sure for each non-terminal is either only one rule or every rule starts
with a terminal or epsilon.
\item Maker sure your parse tree always be left recursive.
\item More you expand your grammar, you can make it more predictive.
\end{itemize}

\section{Conclusion}
\label{sec:org7f115cc}


\begin{itemize}
\item It is important for you to read the material for the first four chapters of the
tex book and be familiar with what is going on with assignment number one.

\item Remember to review all the material related to tokens, lexems, lexical and
syntax analysis.

\item Very important to understand how BNF and EBNF are working and how to generate
strings based on them. You also need to be able to distinguish the valid and
invalid strings.

\item Try to understand how to create a parse tree for a derivation of a grammar and
how to figure out if it is ambiguous or not. You should be able to figure out
to solve the ambiguity it is possible.

\item You should have access to the solution of Assignment number 1. Try to
understand how each of the hleper functions are working and how you could use
them if it is necessary.
\end{itemize}
\end{document}